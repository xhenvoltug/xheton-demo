import { NextResponse } from 'next/server';
import { query } from '@/lib/db';

// GET: List all GRNs with pagination, search, and filters
export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');
    const search = searchParams.get('search') || '';
    const status = searchParams.get('status');
    const offset = (page - 1) * limit;

    let whereConditions = ['grn.deleted_at IS NULL'];
    let queryParams = [];
    let paramIndex = 1;

    if (search) {
      whereConditions.push(`(grn.grn_number ILIKE $${paramIndex} OR supp.supplier_name ILIKE $${paramIndex})`);
      queryParams.push(`%${search}%`);
      paramIndex++;
    }

    if (status) {
      whereConditions.push(`grn.status = $${paramIndex}`);
      queryParams.push(status);
      paramIndex++;
    }

    const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';

    const countRes = await query(
      `SELECT COUNT(*) FROM goods_received_notes grn 
       LEFT JOIN suppliers supp ON grn.supplier_id = supp.id 
       ${whereClause}`,
      queryParams
    );
    const totalCount = parseInt(countRes.rows[0].count || 0);

    const resParams = [...queryParams, limit, offset];
    const res = await query(
      `SELECT grn.*, supp.supplier_name, supp.supplier_code, wh.warehouse_name, u.email as received_by_email
       FROM goods_received_notes grn
       LEFT JOIN suppliers supp ON grn.supplier_id = supp.id
       LEFT JOIN warehouses wh ON grn.warehouse_id = wh.id
       LEFT JOIN users u ON grn.received_by = u.id
       ${whereClause}
       ORDER BY grn.grn_date DESC
       LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`,
      resParams
    );

    return NextResponse.json({
      success: true,
      data: res.rows,
      pagination: {
        page,
        limit,
        total: totalCount,
        pages: Math.ceil(totalCount / limit),
      },
    });
  } catch (err) {
    console.error('GET GRN list error:', err.message);
    return NextResponse.json({ success: false, error: 'Failed to fetch GRNs' }, { status: 500 });
  }
}

// POST: Create GRN with auto-creation of product batches and stock movements
export async function POST(request) {
  try {
    const body = await request.json();
    const { po_id, supplier_id, warehouse_id, grn_date, received_by, delivery_note_number, vehicle_number, driver_name, notes, grn_items } = body;

    if (!supplier_id || !grn_date || !Array.isArray(grn_items) || grn_items.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields: supplier_id, grn_date, grn_items' },
        { status: 400 }
      );
    }

    // Generate GRN number
    const grnNumRes = await query(
      `SELECT COUNT(*) as cnt FROM goods_received_notes WHERE grn_number LIKE 'GRN%'`
    );
    const nextNum = (parseInt(grnNumRes.rows[0].cnt || 0) + 1);
    const grn_number = `GRN${String(nextNum).padStart(6, '0')}`;

    // Create GRN
    const grnRes = await query(
      `INSERT INTO goods_received_notes 
       (grn_number, grn_date, po_id, supplier_id, warehouse_id, received_by, 
        delivery_note_number, vehicle_number, driver_name, notes, status, created_by, updated_by)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
       RETURNING *`,
      [grn_number, grn_date, po_id || null, supplier_id, warehouse_id || null, received_by || null,
       delivery_note_number || null, vehicle_number || null, driver_name || null, notes || null, 'draft', null, null]
    );

    const grn = grnRes.rows[0];

    // Process GRN items with batch and stock movement creation
    for (const item of grn_items) {
      const { po_item_id, product_id, batch_number, quantity_received, unit_cost, manufacture_date, expiry_date } = item;

      if (!product_id || !quantity_received || !unit_cost) {
        return NextResponse.json(
          { success: false, error: 'Each GRN item requires: product_id, quantity_received, unit_cost' },
          { status: 400 }
        );
      }

      // Check product exists
      const prodRes = await query('SELECT id FROM products WHERE id = $1 AND deleted_at IS NULL', [product_id]);
      if (prodRes.rows.length === 0) {
        return NextResponse.json({ success: false, error: `Product ${product_id} not found` }, { status: 404 });
      }

      // Create batch number if not provided
      let finalBatchNumber = batch_number;
      if (!finalBatchNumber) {
        const batchNumRes = await query(
          `SELECT COUNT(*) as cnt FROM product_batches WHERE batch_number LIKE 'BATCH%'`
        );
        const batchNum = (parseInt(batchNumRes.rows[0].cnt || 0) + 1);
        finalBatchNumber = `BATCH${String(batchNum).padStart(6, '0')}`;
      }

      // Create product batch
      const batchRes = await query(
        `INSERT INTO product_batches 
         (batch_number, product_id, warehouse_id, quantity, cost_per_unit, 
          manufacture_date, expiry_date, received_date, supplier_id, status, created_by)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
         RETURNING id`,
        [finalBatchNumber, product_id, warehouse_id || null, quantity_received, unit_cost,
         manufacture_date || null, expiry_date || null, new Date().toISOString().split('T')[0],
         supplier_id, 'active', null]
      );

      const batch_id = batchRes.rows[0].id;

      // Create stock movement (IN)
      const movementNumRes = await query(
        `SELECT COUNT(*) as cnt FROM stock_movements WHERE movement_number LIKE 'STK%'`
      );
      const movementNum = (parseInt(movementNumRes.rows[0].cnt || 0) + 1);
      const movement_number = `STK${String(movementNum).padStart(6, '0')}`;

      await query(
        `INSERT INTO stock_movements 
         (movement_number, movement_type, product_id, batch_id, to_warehouse_id, 
          quantity, unit_cost, reference_type, reference_id, created_by)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
        [movement_number, 'receipt', product_id, batch_id, warehouse_id || null,
         quantity_received, unit_cost, 'purchase', grn.id, null]
      );

      // Update product current_stock
      await query(
        `UPDATE products SET current_stock = current_stock + $1 WHERE id = $2`,
        [quantity_received, product_id]
      );

      // Create GRN item
      await query(
        `INSERT INTO grn_items 
         (grn_id, po_item_id, product_id, batch_number, quantity_received, unit_cost, 
          manufacture_date, expiry_date, quantity_accepted)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
        [grn.id, po_item_id || null, product_id, finalBatchNumber, quantity_received, unit_cost,
         manufacture_date || null, expiry_date || null, quantity_received]
      );
    }

    return NextResponse.json({
      success: true,
      message: 'GRN created successfully with batches and stock movements',
      grn: grn,
    }, { status: 201 });
  } catch (err) {
    console.error('POST GRN error:', err.message);
    return NextResponse.json({ success: false, error: 'Failed to create GRN' }, { status: 500 });
  }
}
